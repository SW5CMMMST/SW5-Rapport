\chapter{Future Works}
This chapter describes the problems whose solutions could help in better solve the problem statement as stated in \myref{sec:problemStatement}. 
Most of these were excluded due to time constraints.

\section{Strongly Connected Networks}
During the analysis phase of the project, an issue came up what if the network is not complete? 
Many of the techniques from the unreliable networks would work in most cases. 
For example when connecting to a network. 

An incomplete network is a network where the individual devices might not have a direct connection to every other device in the network. 
This complicates communication between devices.

\tikzfigure{LinearNetwork.tikz}{A linearly connected network where every node has at most two connections.}{linearNetwork}

In this case, the other devices in the network must figure out whether to act as a relay for a message. 
The simple solution is to repeat all known information. 
This would make the message length long and by that account also the frame length. 
Communication would become slow.

A worst case for a network of four devices is illustrated by \myref{fig:linearNetwork}.
When device 1 wants to send a message to device 4, the message needs to go through device 2 and 3 first.

The implementation of this would allow many other use cases for the protocol. 

\section{Interrupt based library}

The Arduino platform includes support for interrupt based programming.
This means that every $\delta$ milliseconds an interrupt in the user program could occur.
In this interrupt the protocol specific details could be handled, such as transmitting and reciving.

The main advantage of this would be that the timer gives a better guarrentee that the user code will not exceed the expected duration.
The disadvantage of this would be that the interface could become less obvious, and it would make the code vunerable to race conditions.

Another thing to note is that on the Arduino Nano and Uno there are three timer interrupts.
One is used by the delay function another is used by radiohead leaving exactly one left for the protocol.
This would mean that every other library which uses timers would be uncompatible, unless RadioHead and the protocol could share interrupt.
But this would require a lot of changes to both libraries.

\section{Speed optimizations}

The protocol as it is described takes approximately $66 + (6 \times l)$ milliseconds to send a package of length $l$. 
This means that a message length of 16 bytes would give 162 miliseconds to send.
If the user code takes up a quater of the time slot then the slot length must be approximately 200 miliseconds.
In a network with $n$ devices, this means that the frame length must be equal to $200 \times (n + 1)$.
This means that in a network of just four devices the frame length would be a second.

There are many ways to optimize this, but this section will focus on these possible improvements: 
Skip unnessary transmissions, increase the bit rate, ?? and parallel communication for disconnected devices.

\paragraph{Skip unnessary transmissions} 
When the protocol is functioning there is a chance that a device will not have anything to send in its slot.
Currently, the device would send the last message again.
Filling the slot with information that would be redundant.
This could be done by having a signal that indicates to the other devices that this slot should be skipped.

\paragraph{Increase the bit rate} 
An obvious way to increase communication speed is to increase the bit rate.
This could introduce unreliability for the communication at higher rates. 
But even for smaller increases it could have a significant speed improvement.
The best way to implement this would be to have the user be in control of the bit rate.
In this way the user could set the rate according to how reliable and fast the protocol needs to be.

\paragraph{Parallel communication}
This third possible implovement assumes that the protocol works in a strongly connected network. 
If in a network of more than three devices contains two devices who can not hear eachother and none of their neighbors can hear both of them. 
Then there would not be any reason not to have them in the same slot.
This would need some way of knowing what slots neighbors and their neighbors occopies.
One way to implement this would need a rearrange phase where every device tries to rearrange the assigned slots. 
In this phase all devices would send their neighbors to eachothers which the devices uses to select a slot.
When a new device connects to the network then the whole network enters this phase.
The problem with this is that the communication is paused in the new phase in the entire network.
This has the added advantage of a build-in garbage collector for dead devices.