\chapter{Discussion}\label{Discussion}
This chapter will reflect on the choices made throughout this paper in respect to the problem statement in \myref{sec:problemStatement}, which was derived from wanting to find a cheaper alternative to Wi-Fi communication in simpler systems.
Following this chapter the \myref{conclusion} will conclude on the success, or lack thereof, for those choices.

\bigskip \noindent
Prior to development both hardware and single-frequency communication methods were taken into account.
For communication the choice ended on TDMA, while there exists enough methods to fill this entire paper with just that, most are merely mutations of TDMA adapted to more specific scenarios, as such TDMA was chosen as the primary inspiration for the protocol development.
As for hardware several embedded systems were considered including the popular Raspberry Pi yet the choice still fell onto Arduino as it fit better in the scope of the project due to price, hardware specifications and availability.

Tests were run on the hardware showing just how unreliable the wireless technology in the RF-modules was.
To counter this an antenna was constructed adhering to the physics of radio communication, this was further tested against an antenna of random length and proved to be significantly better than both none and the antenna of random length.
Any multiple of the chosen antenna length would fit according to the physics used in \myref{rfmodule}.
This however would be unnecessary as the antenna proved to work upwards of 28 meters without any significant change in package loss.
28 meters happens to be more than enough when applications considered are alarms, home automation or similar systems.

\bigskip \noindent
Following the hardware analysis and testing the problem was split into sub-problems all represented using graph theory.
The four sub-problems were the result of considering two variables, communication and device placement.
While the device placement was a sensible consideration as the two scenarios are significantly different one can argue as to whether the communication considering was as well, or perhaps it should have been more explicit.
As it happens the CCUC-solution has not been implemented, but merely designed.
This is partly due to unforeseen sub-iterations in the CCRC-solution pertaining to certain edge cases requiring entire design structures.
One of these in particular would cause a complication in when expanding into the CCUC-problem as a consequence of the consensus idea, the sub-iteration in question is removal of dead devices and by extension reduction of time-slots.
What really causes the problem here is that this requires that value can both rise and fall, instead of only rise.
If one had spotted these edge cases in the initial partition of problems one could have defined which sub-iterations to consider for each problem such that sub-iterations which would require a significant change once expanding the problem, would not be designed in the former problem as to avoid a rework of an entire sub-iteration.



How realistic is the assumptions made for protocol? Particularly the CC scenario in constrast to the SC scenario

Realistic application use - consider length of a frame

Success of the project, practical example


Do your results provide answers to your testable hypotheses? If so, how do you interpret your findings?
Do your findings agree with what others have shown? If not, do they suggest an alternative explanation or perhaps a unforseen design flaw in your experiment (or theirs?)
Given your conclusions, what is our new understanding of the problem you investigated and outlined in the Introduction?
If warranted, what would be the next step in your study, e.g., what experiments would you do next?

Disc: Intro to nao

Problem, alrdy solved so why bother?
Hardware choice
Hardware tests, point and outcome
Math models, why the split?
Reqs, where they met? how well?
CCRC alot more its than expected
Edge cases
CCUC addition so slight, why bother splitting UC and RC?
UPPAAL to real code how?
Real code how does it even work

UC expansion
Double send, value?
Alternatives
Things that were designed but not implemented+

