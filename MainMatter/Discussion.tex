\chapter{Discussion}\label{Discussion}
This chapter will reflect on the choices made throughout this paper in respect to the problem statement in \myref[name]{sec:problemStatement}.

% General Design methodology + Model driven software development
\bigskip \noindent
By using a method resembling model-driven software development, we ensured that when a design was finished and had been modelled, implementation seemed trivial.
Ensuring, as long as the code fit the model, the code would work every time for the \gos{ccrc}-problem and within a certain probability for the \gls{ccuc}-problem.
This proved to be successful, as the work-flow seemed natural, and it helped bring up discussions of the design significantly earlier, than a more hands on approach would have done.
Even though, using the tools for modelling embedded systems proved difficult at first, because of a lack of experience, which slowed down the development process; however, the pros outweighs the cons, because of the advantages of discovering changes to  the design early.

The \gls{ccrc}-problem being an implausible scenario, simply proves that the theoretical problem was solved, however for the \gls{ccuc}-solution the model checking provides proof that the protocol works in most of the thousands of possible scenarios, something one could not prove through a practical example.


The alternative method of development for a solution would be developing through coding then proceeding to model check the code already created.
The work flow of doing this however would quite possibly increase the work done, as finding an error, edge case or other potential issues are significantly more difficult to do in 500 lines of code, rather than using a model checker on already designed pseudocode and flow diagrams.
One could combine the code with the model checker, but creating a model to check, is significantly more problematic to do from 500 lines of code rather than from a flow diagram.

% Sub-problem split and dilemma
\bigskip \noindent
One of these in particular would cause a complication in when expanding to the \gls{ccuc}-problem as a consequence of the consensus idea, the sub-iteration in question is removal of dead devices and by extension reduction of time-slots.
What really causes the problem here is that this requires that the value $n$, number of time-slots in the network, can both rise and fall, instead of only rise.
If one had spotted these edge cases in the initial partition of problems one could have defined which sub-iterations to consider for each problem such that sub-iterations which would require a significant change once expanding the problem, would not be designed in the former problem as to avoid a rework of an entire sub-iteration.

%CCUC Expansion
\bigskip \noindent
In expanding to the \gls{ccuc}-problem several ideas on handling this were presented, both in regard to avoidance and damage control.
While only one of the avoidance ideas, redundant messaging, has been applied it is not a reason to disregard the rest as possible techniques.
In choosing an idea to use one must also consider the cost, for both of the ideas mentioned in \myref[name]{sub:avoidance} it becomes a strain on the time-slot length, thus for an application one might not want to use these particular ideas.
This is particularly worth considering if the network is already running with a high reliability, in that case it may be better to perform some sort of damage control on devices that become desynchronised, whether this is by restarting or using one of the designed damage control ideas. 

If the reliability is low, but reducing the time-slot length is of importance, it further becomes important to consider the impact of losing a package for a given application in order to decide whether increasing reliability by increasing time-slot length is worth it.
For the opposite scenario where reliability is of extreme importance it may also be worth increasing the time-slot length even further by sending the message more than twice while also implementing a damage control idea which is not to simply reset the device.

%Ending the chapter
\bigskip \noindent
Ideas for damage control were not the only things not implemented which had been designed, this is an unfortunate side effect of the time constraints on the project