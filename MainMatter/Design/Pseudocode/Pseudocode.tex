\section{Pseudocode Description}
In this section key components of the designed TDMA protocol will be presented.
Firstly an informal description will be given, followed by relevant flowcharts and pseudocode examples.
The protocol presentation have been separated into two sections - general case and special cases. 
The general case is what will be happening most of the time, whereas special cases are scenarios which rarely happen. 

From here on a set of frequently used variables will be referenced using the following greek letters: 
\begin{description}[labelindent=\parindent]
    \item[$\alpha$] The number of time slots per frame
    \item[$\beta$] The total number of units in the network
    \item[$\kappa$] The current unit's time slot id in the frame
    \item[$\lambda$] The current time slot in the frame
    \item[$\rho$] The length of a time slot
\end{description}  
\noindent
Furthermore the following should be true in all cases: 
\begin{enumerate}[label=\itshape \alph*\upshape)]
    \item Each unit gets a time slot in the frame, this is given by their join time, meaning that the first device will have the first time slot in each frame, and so on.
    \item There is an empty time slot in the end of each frame which can be used by new devices to join the network.
    \item Devices currently in the network should alter their current state to adapt to the new device.
    \item In a devices own time slot it may transmit a message to the other devices.
    \item In other devices' time slots the device receive their transmission and act upon them if applicable. Otherwise the device use the time to do some preemptable execution of a calculation.
\end{enumerate}
                    
\subsection{General Case} % (fold)
\label{sub:general_case}
Generally the devices should be executing an infinite loop, which transmits and receives payloads.
This loop should only be stopped, when the network needs to be reconfigured.
However said reconfiguration and how to initiate a network are special cases and will be described in \myref{sub:special_cases}.
\todo[inline]{Informal description of main loop and payload processing} 
\todo[inline]{Flowchart of main loop}  

\begin{lstlisting}[style=customc,mathescape=true,caption={Pseudocode example of the main loop}]  
mainLoop() // This is repeated forever after startup
  if($\lambda$ == $\kappa$) // This device's turn to transmit
  	tx_payload = makePayload() // Returns a payload with appropriate variables set.
  	transmitPayload(tx_payload)
  else // This device should receive
  	timer = startTimer($\rho$) // Starts a timer that shows time left of timeslot
  	rx_payload = receive($\rho$) // $\rho$ is max timeout to wait. 
  	if(rx_payload != null) // If a payload is received...
  	    processPayload(rx_payload)
  	while(timer.timeLeft > 0 ) // While the timeslot still has some time left
  	    executeTask(timer.timeLeft)   // Do some preemptable task for the remainder of the timeslot
  	$\lambda$ = $\lambda$ + 1 mod $\alpha$   
\end{lstlisting}  

\begin{lstlisting}[style=customc,mathescape=true,caption={Pseudocode example of the method that processes the payload}]  
processPayload(rx_payload)
  syncDevice(rx_payload) // Use information in payload to re-synchronise
  switch(rx_payload.type)
    case PING:
      return
    case ANNOUNCEMENT:
      $\beta$ += 1
      $\alpha$ += 1
      if(rx_payload.Worst_Case > $\rho$)
        $\rho$ = rx_payload.Worst_Case
      return
    case ACTION:
      if(rx_payload.target == $\kappa$)
        execute(rx_payload.instruction)
      return         
\end{lstlisting}
% subsection general_case (end)   

\subsection{Special Cases} % (fold)
\label{sub:special_cases} 
\todo[inline]{Informal description of special cases maybe some kind of list that can be referenced?}  


\todo[inline]{Split of this into smaller part maybe}
\begin{lstlisting}[style=customc,mathescape=true,caption={Pseudocode example of special case functions}]
startup() // This is called at startup                                           
  network = listenForNetwork(timeout) // Listen for and return active network, otherwise stops after timeout.
  if(network != null) // If there already exists a network...
    connectToNetwork(network)
  else                // If no existing network is found...
    createNetwork()
  while(true)
    mainLoop()
  
createNetwork()
  $\alpha$ = 2
  $\beta$ = 1
  $\kappa$ = 1
  $\lambda$ = 1
  $\rho$ = THIS_UNIT_WORST_CASE_EXEC_TIME
  
connectToNetwork(network)
  $\alpha$ = network.$\alpha$
  $\beta$ = network.$\beta$
  $\kappa$ = network.$\alpha$ // This is the empty slot.
  $\lambda$ = network.$\lambda$ + 1 mod $\alpha$
  $\rho$ = max(THIS_UNIT_WORST_CASE_EXEC_TIME, network.$\rho$)
  transmitPayload(CreateAnnouncePacket())
  // TODO: Check if unit is connected to network, if not use exponential backoff to assure that it will in finite time.
\end{lstlisting}   
% subsection special_cases (end)         