\section{Pseudocode Description}
In this section key components of the designed TDMA protocol will be presented.
Firstly an informal description will be given, followed by relevant flowcharts and pseudocode examples.
The protocol presentation have been separated into two sections - general case and special cases. 
The general case is what will be happening most of the time, whereas special cases are scenarios which rarely happen.
On \myref{fig:psuedo_flow} it can be seen the flow of how a device acts when turned on and either connects to a network or create it's own network.

\tikzfigure{PsuedoFlowDiagram}{Flow diagram showing how a device act when turned on and trying to connect to a network}{psuedo_flow}

From here on a set of frequently used variables will be referenced using the following letters: 
\begin{description}[labelindent=\parindent]
    \item[$n$] The number of time slots per frame
    \item[$d$] The total number of devices in the network
    \item[$k$] The current device's time slot id in the frame
    \item[$i$] The current time slot in the frame
    \item[$\delta$] The length of a time slot
\end{description}  
\noindent
Furthermore the following should be true in all cases: 
\begin{enumerate}[label=\itshape \alph*\upshape)]
    \item Each unit gets a time slot in the frame, this is given by their join time, meaning that the first device will have the first time slot in each frame, and so on.
    \item There is an empty time slot in the end of each frame which can be used by new devices to join the network.
    \item Devices currently in the network should alter their current state to adapt to the new device.
    \item In a device's own time slot it may transmit a message to the other devices.
    \item In other devices' time slots the device receive their transmission and act upon them if applicable. Otherwise the device use the time to do some preemptable execution of a calculation.
\end{enumerate}
                    
\subsection{General Case} % (fold)
\label{sub:general_case}
Generally the devices should be executing an infinite loop, which transmits and receives payloads.
This loop should only be stopped, when the network needs to be reconfigured.
However said reconfiguration and how to initiate a network are special cases and will be described in \myref{sub:special_cases}.
\todo[inline]{Informal description of main loop and payload processing} 

\begin{lstlisting}[style=pseudocode,mathescape=true,caption={Pseudocode example of the main loop}] 
Device$_{id} =$ local $n, i, k, \delta, \rho, \text{clock } x$ 
procedure mainLoop()
	while true do
		wait until $x \geq \delta$
		$x \leftarrow 0$
		$i \leftarrow (i \text{ mod } n) + 1$		// Update current slot
		if $i = k$ then
			$Update()$				// Updates the data to be sendt
			$transmit(i, n, id, data)$
		else 
			while $x \leq \rho$ do
				if $recived(i', n', id', data')$ then
					$remember(id', data')$
					goto process
				end
			end
		end
		process:
		$doWork()$	// Must take less time than $\delta - \rho$	
	end
\end{lstlisting}  

%\begin{lstlisting}[style=customc,mathescape=true,caption={Pseudocode example of the method that processes the payload}]  
%processPayload(rx_payload)
%  syncDevice(rx_payload) // Use information in payload to re-synchronise
%  switch(rx_payload.type)
%    case PING:
%      return
%    case ANNOUNCEMENT:
%      $d$ += 1
%      $n$ += 1
%      if(rx_payload.Worst_Case > $\delta$)
%        $\delta$ = rx_payload.Worst_Case
%      return
%    case ACTION:
%      if(rx_payload.target == $k$)
%        execute(rx_payload.instruction)
%      return         
%\end{lstlisting}
% subsection general_case (end)   
            