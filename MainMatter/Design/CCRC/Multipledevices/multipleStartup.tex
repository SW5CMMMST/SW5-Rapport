\section{Multiple Startup Issue}\label{sec:MSI-CCRC}
The activation of multiple devices at any point in time such that two or more devices are active but not in a network causes a problem that must be handled differently for each of the two aforementioned cases.
The first case, which will be handled in this section, is in the case where no network exists prior to the activation of devices.
As has been established earlier the time required to guarantee no network exists is $\delta \times 3$.
From the moment that a device has determined no network exists it spends $\delta$ time to announce the existence of a network.
As such if a multiple of devices are activated within $\delta$ time, relative to the firstly activated device, multiple networks will be established.
By this it follows that if one can guarantee devices start with an offset of at least $\delta$ the problem is solved for every case.
In an effort to solve this several different approaches can help solve the issue however none of them can guarantee that a multiple of networks will never occur with 100 \% certainty. 
As such implementing concepts from each approach may yield the best result.

\begin{description}[labelindent=\parindent]
    \item[Unique Offset]\hfill\\
    Each device listens for a network for a uniquely specified amount of time rather than $\delta \times 3$.
    \item[Randomly Create]\hfill\\
    Once a device is done listening for a network it either creates its own network or resets and starts listening again.
    \item[Kill the Network]\hfill\\
    If a device is alone in a network for too long it may decide to kill the network and start listening again.
    \item[Exponential variables]\hfill\\ 
    Inspired by exponential backoff one could use a similar concept to alter some of the former ideas in an effort to make them more likely to positively increase the ratio between successful and unsuccessful attempts.
\end{description} 

\subsection{Unique Offset}
Using the ID of each device one could guarantee that no device used the same multiple of $\delta$ prior to establishing their network by the formula $\delta \times 3 + \delta \times ID$.
This however assumes device IDs are activated continuously for it to work.
In the case where initially the device with ID 2 is turned on and exactly $\delta$ time later the device with ID 1 is turned on they would still both create a network, as such this is not a valid solution to the problem.

\subsection{Randomly Create}\label{RCreate}
For this each device would need to implement some sort of chance factor to determine whether or not to create a network.
This could be determined by filtering the result of a random seed such that even results would create a network and odd would listen again which would obtain a 50/50 chance.
The problem with this is while it gives the opportunity to for two devices to start within the same time-slot without both creating a network at the same time, this is no guarantee; as such this would further require the implementation of a recovery method.

\subsection{Seppuku}\label{KtN}
Deterministic, factors to change, and non-deterministic, recovery technique


\subsection{Exponential variables}
Without going into detail exponential backoff is a technique of increasing an exponent after every unsuccessful attempt in order to reach more acceptable odds of success.
Amongst others it is used in Ethernet to reschedule data transfer after collisions. \citep{Ebackoff}
Using the idea of an increasing exponent it can be applied to both \myref{RCreate} and \myref{KtN} to increase odds of success.
\subsubsection*{Randomly Create}
For the idea of using an exponent in randomly create, the chance of creating should start of relatively low.
Starting with a lower chance the algorithm would for each unsuccessful attempt of creating a network increase the chance.
In an effort to end up with different chances for each device trying to create, the algorithm would have to work on a unique value such as the address of each device.
While this does not remove the chance of two networks still starting at the same time, it does reduce the chance as one device will have better odds of creating than any other device turned on in the same moment.
\subsubsection*{Seppuku}
 $\delta \times 3 + \delta \times address^a$

\bigskip \noindent
As was mentioned in \myref{RCreate} that technique still allows for multiple networks as it has no recovery, however combining that technique with the recovery technique mentioned in \myref{KtN} would provide a working solution.
The effects of randomly create would be a better chance of only one network being created even when two or more devices are turned on at once where as killing the network would act as a way to recover if a multiple of devices got through.
For the method of killing off the network, using the fixed method one would not have to rely on any randomness, however this would be at the cost of how long it would take to establish a network in the case that several devices were allowed to start one in the first place.

The following flow chart and pseudo code will show how and exactly what combination of ideas will be used.
Following the flow chart certain points of interest in \myref{pseudo_flowMultiStart} will be explicitly explained.
\tikzfigure{PseudoFlowDiagramMultiStart}{Revised flow diagram showing how a device acts during the Initialization phase if no networks are detected.}{pseudo_flowMultiStart}

\paragraph{Search for network}
The initial action after starting a device states to search for a network.
This is done for $\delta \times 3 + \delta \times address^a$. 
The addition to the expression, $\delta \times address^a$, ensures that after an initial failure devices will no longer listen for the same amount of time ensuring scenarios in which only one device will create a network while others are still listening, also in the case where they died at the same time.
\paragraph{Create Network?}
This decision is a 50/50 chance to either create a network or go back to searching for one, as this does not increase $a$ it does not affect the time spent listening.
\paragraph{Alone the network?}
For this decision the device checks whether or not it is alone in the network as if it is not, a special version of \texttt{mainLoop()}, making use of the kill network method, should be run as two or more networks could be jamming each other.
\paragraph{Time to Die?}
This decision checks for how many frames a network has been alone by executing the folliwng expression, $f > (address \% 100) + C$, where $f$ denotes a count for how many frames a device has been alone in the network and $C$ is a constant which ensures that low addresses still are allowed to run several frames before dieing.