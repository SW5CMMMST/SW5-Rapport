\section{Multiple Startup Issue}\label{sec:MSI-CCRC}
The activation of multiple devices at any point in time such that two or more devices are active but not in a network causes a problem that must be handled differently for each of the two aforementioned cases.
The first case, which will be handled in this section, is in the case where no network exists prior to the activation of devices.
As has been established earlier the time required to guarantee no network exists is $\delta \times 3$.
From the moment that a device has determined no network exists it spends $\delta$ time to announce the existence of a network.
As such if a multiple of devices are activated within $\delta$ time, relative to the firstly activated device, multiple networks will be established.
By this it follows that if one can guarantee devices start with an offset of at least $\delta$ the problem is solved for every case.
In an effort to solve this several different approaches can help solve the issue however none of them can guarantee that a multiple of networks will never occur with 100 \% certainty. 
As such implementing concepts from each approach may yield the best result.

\begin{description}[labelindent=\parindent]
    \item[Unique Offset]\hfill\\
    Each device listens for a network for a uniquely specified amount of time rather than $\delta \times 3$.
    \item[Randomly Create]\hfill\\
    Once a device is done listening for a network it either creates its own network or resets and starts listening again.
    \item[Kill the Network]\hfill\\
    If a device is alone in a network for too long it may decide to kill the network and start listening again.
    \item[Exponential Backoff]\hfill\\ 
    Inspired by exponential backoff one could use a similar concept to alter some of the former ideas in an effort to make them more likely to positively increase the ratio between successful and unsuccessful attempts.
\end{description} 

\subsection{Unique Offset}
Using the ID of each device one could guarantee that no device used the same multiple of $\delta$ prior to establishing their network by the formula $\delta \times 3 + \delta \times ID$.
This however assumes device IDs are activated continuously for it to work.
In the case where initially the device with ID 2 is turned on and exactly $\delta$ time later the device with ID 1 is turned on they would still both create a network, as such this is not a valid solution to the problem.

\subsection{Randomly Create}\label{RCreate}
For this each device would need to implement some sort of chance factor to determine whether or not to create a network.
This could be determined by filtering the result of a random seed such that even results would create a network and odd would listen again.
The problem with this is while it gives the opportunity to for two devices to start within the same time-slot without both creating a network at the same time, this is no guarantee; as such this would further require the implementation of recovery.

\subsection{Seppuku}\label{KtN}
This technique would allow for multiple networks to create but instead work as a sort of recovery technique.
If a network is alone for too long, as no devices will be able to join if several networks are jamming each other, the device will kill the network and reset itself to once again look for other networks.
This can be done either by chance or by a fixed number.
For the on chance to kill the network the device would after each frame run an algorithm which would determine whether or not the network should kill itself.
\bigskip \noindent
For the fixed time before kill; if a network is online for a number of frames equal to $address + C$, where the C is a constant that ensures a network will not die too quick, two networks will die at closest one frame from each other.
In the edge case where two have been started at the exact same point in time and have addresses where $address_1 - address_2 = 1 \lor address_2 - address_1 = 1$ they will die within one frame of eachother, and as such one will have its next creation of a network delayed by one frame relative to the other network.
The offset of one frame is enough that a network can die, recreate and transmit before the other network recreates in the previously mentioned edge case.
The problem with this solution occurs when more than two devices are activated within one frame, in that case all but one network would have to die off within two frames for a network of multiple devices to successfully be established; otherwise the devices would repeat an endless cycle of creating and killing networks due to too many networks constantly jamming each other.
This only gets worse over time as any new device turned on will join the cycle of jamming.

\subsection{Exponential Backoff}
Without going into detail exponential backoff is a technique of increasing an exponent after every unsuccessful attempt in order to reach more acceptable odds of success.
Amongst others it is used in ethernet to reschedule data transfer after collisions. \citep{Ebackoff}
Using the idea of an increasing exponent it can be applied to both \myref{RCreate} and \myref{KtN} to increase odds of success.
\subsubsection*{Randomly Create}
For the idea of using an exponent in randomly create, the chance of creating should start of relatively low.
Starting with a lower chance the algorithm would for each unsuccessful attempt of creating a network increase the chance.
In an effort to end up with different chances for each device trying to create, the algorithm would have to work on a unique value such as the address of each device.
While this does not remove the chance of two networks still starting at the same time, it does reduce the chance as one device will have better odds of creating than any other device turned on in the same moment.
\subsubsection*{Seppuku}
For the chance to kill implementation this would work similarly to what was mentioned about randomly create. 
However for the fixed version it would work differently.
For the fixed version the exponent could be implemented in the expression which already uses the unique address to decide when the network should die.
The expression would then instead look like $address^a + C$ where $a$ defines the current attempt to find the network.
As was mentioned in \myref{KtN} for the recovery to work with more than two devices in the network all devices but one has to die within two frames or they will create new networks due to jamming.
If the exponent is implemented as in the previous example these networks would be alive for exponentially longer.
While at some point the networks might hit the edge case where they would finally connect, that is the unlikely outcome.

As aforementioned killing the network is a recovery technique, this also provides the opportunity of altering factors otherwise having to remain constant.
The restriction of all networks but one having to die off within two frames is a result of only listening for three frames.
As such adding in the exponential factor to the listening part might provide a better chance of success.
The previously established time spend listening would then change to a formula implementing and exponent such as $\delta \times 3 + \delta \times address^a$ where a once again $a$ denotes amount of attempts, for the sake of keeping the single device scenario intact this would be indexed by 0.
This would cause networks to be listening for increasing lengths rather than ending up in a lengthy cycle of jamming each other.

\bigskip \noindent
As was mentioned in \myref{RCreate} that technique still allows for multiple networks as it has no recovery, however combining that technique with the recovery technique mentioned in \myref{KtN} would provide a working solution.
The effects of randomly create would be a better chance of only one network being created even when two or more devices are turned on at once where as killing the network would act as a way to recover if a multiple of devices got through.
For the method of killing off the network, using the fixed method one would not have to rely on any randomness, however this would be at the cost of how long it would take to establish a network in the case that several devices were allowed to start one in the first place.
The following flow chart and pseudo code will show how and exactly what combination of ideas will be used.



\tikzfigure{PsuedoFlowDiagramMultiStart}{Revised flow diagram showing how a device acts during the Initialization phase if no networks are detected.}{pseudo_flowMultiStart} 