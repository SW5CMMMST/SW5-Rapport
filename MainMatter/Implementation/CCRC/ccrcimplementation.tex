\noindent
The ability to have a user application have also been implemented, but as it hasn't been described in detail, and it is not the main focus this has been omitted from this chapter.
In the code examples some code used for debugging or testing have been removed as it is irrelevant for the working protocol, however the full code is available in \myref{app:CCRC_CODE}. 

This chapter will explain how we implemented the main points of the protocol; this is the timing on the Arduino, how an Arduino can create and join a network, and lastly how the main loop works. 

\subsection{Timing on the Arduino}
To acquire relative time on Arduino the following constructs are used: A global unsigned variable, a reset function and a get function.
The variables and functions used to implement timing can be seen on \myref{lst:ccrc:timing}.
This construction can accurately time the length of time-slots and its constituents. 
 The get function also handles overflowing of the \texttt{millis()} function. \texttt{millis()} returns an unsigned integer, and subtracting another unsigned variable from an unsigned variable unsigned arithmetic is used. In unsigned arithmetic calculating the difference between a small number and a large number, will result in the difference from the large number to its maximum value in its bit structure plus the smaller number. An example is two unsigned 8-bit integers 4 and 250. In unsigned arithmethic 4 - 250 will result in 10. The difference between 250 and the max in 8-bits which is 256 is 6, and the smaller number is 4, which yields the final calculation 4+6 which is equal to 10. For the implementation the same thing happens when using \texttt{millis()} in the case of the implementation the same thing will happen, where the difference will be correctly calculated.

 
Additionally when joining a network the device needs to wait for the next timeslot before entering the mainloop. 
This is done with the function \texttt{waitForNextTimeslot} which takes the argument the size of the payload received, then calculates how much is left of the timeslot, and waits for that period. 
It is possible to accurately calculate how long it took to send the payload, the formulae for this is found in the test, see \myref{ssub:radiohead_time_sent_test} \myref{cha:radiohead_time_sent_test}.
This function is also used every time a payload is received to ensure that the devices in the network remains synchronised. 

\begin{figure}
\begin{lstlisting}[style=customc,caption={The variables and functions used to implement timing.},label={lst:ccrc:timing}]
MISSING
\end{lstlisting}
\vspace{-20pt}
\end{figure}
\todo[inline]{Troels lovede at sætte den rigtige kode ind}

\subsection{Upstart: Creating or Joining a Network}
When each Arduino starts it determines if there is a network in progress and join it. 
If it cannot find a network then it should create its own network, so that others can join it. 
The worst case time required to determine whether a network exists is roughly $3 \times \delta \leq t_0$ for the CCRC-problem, as determined in \myref{sub:setupCCRC}, where $t_0$ is the maximum time. 
This is referred to as \texttt{INIT\_WAIT} in the code and sets the limit for how long an Arduino listens before creating its own network. 
In \myref{lst:ccrc:startup} the startup code is shown. 
\begin{figure}
\begin{lstlisting}[style=customc,caption={Startup, if a network is found join it, if not create one.},label={lst:ccrc:startup}]
MISSING
\end{lstlisting}
\end{figure}
\todo[inline]{Troels lovede at sætte koden ind.}
\subsection{Main Loop: Normal Network Operation}
The main loop executes both the processing phase and the communication phase.
First user-code is executed, this lasts at most \texttt{$DELTA_{PROC}$} time, which is $\delta_{proc}$ in the design. 
Firstly each device should either transmit or receive depending on the current timeslot. 
If the current timeslot belongs to a device then that device should transmit otherwise it should receive, note that there is no special case for the empty slot in which new devices can join the network.
There exists no special case for a device to join as communication is perfect thus the device can simply transmit in the empty slot letting everyone know that the network has increased, and the device is seizing the former empty slot.
\begin{figure}
\begin{lstlisting}[style=customc,caption={Important parts of the main loop.},label={lst:ccrc:rxortx}]
MISSING
\end{lstlisting}
\end{figure}
\todo[inline]{Troels lovede at sætte koden ind.}

The \texttt{tx()}-function prepares and transmits the payload, this can optionally include user-data, this is the first parameter, and the second is the length of the data.
It then waits for the timeslot to end, as this is a static time for every timeslot, then it resets the clock on the device and the main loop starts over.
The \texttt{rx()}-function asks Radiohead whether a full payload has been received. 
If a full payload has been received the payload is then copied to \texttt{inPayload} and then returns true.
Following \texttt{rx()} the while-loop on line 16 in \myref{lst:ccrc:rxortx} will break, then it waits for the timeslot to end and then resets the clock and starts the loop over. 