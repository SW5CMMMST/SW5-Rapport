\noindent
The ability to have a user application have also been implemented, but as it hasn't been described in detail, and it is not the main focus this has been omitted from this chapter.
In the code examples some code used for debugging or testing have been removed as it is irrelevant for the working protocol, however the full code is available in \myref{app:CCRC_CODE}. 

This chapter will explain how we implemented the main points of the protocol; this is the timing on the Arduino, how an Arduino can create and join a network, and lastly how the main loop works. 

\subsection{Timing on the Arduino}
To acquire relative time on Arduino the following constructs are used: A global variable, a reset function and a get function.
The variables and functions used to implement timing can be seen on \myref{lst:ccrc:timing}.
This construction can accurately time the length of time-slots and its constituents. 
Additionally when joining a network the device needs to wait for the next timeslot before entering the mainloop. 
This is done with the function \texttt{waitForNextTimeslot} which takes the argument the size of the payload received, then calculates how much is left of the timeslot, and waits for that period. 
It is possible to accurately calculate how long it took to send the payload, the formulae for this is found in the test, see \myref{ssub:radiohead_time_sent_test} \myref{cha:radiohead_time_sent_test}.
This function is also used every time a payload is received to ensure that the devices in the network remains synchronised. 

\begin{figure}
\begin{lstlisting}[style=customc,caption={The variables and functions used to implement timing.},label={lst:ccrc:timing}]
unsigned long x = 0;

unsigned long getClock(unsigned long * x_0){
    return millis() - *x_0;
}

void resetClock(unsigned long * x_0) {
    *x_0 = millis();
}

void waitForNextTimeslot(uint32_t payloadSize) {
    uint32_t sentTime = 66 + (6 * payloadSize);
    uint32_t timeLeft = DELTA_COM - GUARD_TIME_BEFORE_TX - sentTime;

    resetClock(&x);
    while(getClock(&x) <= timeLeft);
    resetClock(&x);
}

\end{lstlisting}
\vspace{-20pt}
\end{figure}
\subsection{Upstart: Creating or Joining a Network}
When each Arduino starts it determines if there is a network in progress and join it. 
If it cannot find a network then it should create its own network, so that others can join it. 
The worst case time required to determine whether a network exists is roughly $3 \times \delta \leq t_0$ for the CCRC-problem, as determined in \myref{sub:setupCCRC}, where $t_0$ is the maximum time. 
This is referred to as \texttt{INIT\_WAIT} in the code and sets the limit for how long an Arduino listens before creating its own network. 
In \myref{lst:ccrc:startup} the startup code is shown. 
\begin{figure}
\begin{lstlisting}[style=customc,caption={Startup, if a network is found join it, if not create one.},label={lst:ccrc:startup}]
resetClock(&x);

bool foundNetwork = false;
while(getClock(&x) <= INIT_WAIT && !foundNetwork) {
    if(rx()) {
        foundNetwork = true;
    }
}

if(foundNetwork) {
    netStat.i = inPayload.header.currentSlot;
    netStat.n = inPayload.header.slotCount + 1;
    netStat.k = inPayload.header.slotCount - 1; // EmptySlot, is 0-indexed
    setPayloadHead(&outPayload, netStat.i,  netStat.n, address);
    waitForNextTimeslot(inPayloadSize);
} else {
    netStat.n = 2;
    netStat.k = 0;
    netStat.i = 1; // Such that when we loop it increments to
    setPayloadHead(&outPayload, netStat.i,  netStat.n, address);
}
resetClock(&x);
// Main loop begins now.
\end{lstlisting}
\end{figure}
\subsection{Main Loop: Normal Network Operation}
The main loop executes both the processing phase and the communication phase.
First user-code is executed, this lasts at most \texttt{$DELTA_{PROC}$} time, which is $\delta_{proc}$ in the design. 
Firstly each device should either transmit or receive depending on the current timeslot. 
If the current timeslot belongs to a device then that device should transmit otherwise it should receive, note that there is no special case for the empty slot in which new devices can join the network.
There exists no special case for a device to join as communication is perfect thus the device can simply transmit in the empty slot letting everyone know that the network has increased, and the device is seizing the former empty slot.
\begin{figure}
\begin{lstlisting}[style=customc,caption={Important parts of the main loop.},label={lst:ccrc:rxortx}]
userCodeRunonce();
while(getClock(&x) <= DELTA_PROC) {
    userCodeRepeat();
}

nextSlot(); // Increment the timeslot
if(netStat.i == netStat.k) { 
    // Transmit!
    delay(GUARD_TIME_BEFORE_TX);
    tx(NULL, 0);
} else {
    // Receive
    bool gotMessage = false
    while(getClock(&x) <= TIMESLOT_LEN && !gotMessage) {
        if(rx()){
            resync(); // Takes the infomation from the recived payload.
            foundNetwork = true;
        }
     }
}
waitForNextTimeslot(inPayloadSize);
\end{lstlisting}
\end{figure}

The \texttt{tx()}-function prepares and transmits the payload, this can optionally include user-data, this is the first parameter, and the second is the length of the data.
It then waits for the timeslot to end, as this is a static time for every timeslot, then it resets the clock on the device and the main loop starts over.
The \texttt{rx()}-function asks Radiohead whether a full payload has been received. 
If a full payload has been received the payload is then copied to \texttt{inPayload} and then returns true.
Following \texttt{rx()} the while-loop on line 16 in \myref{lst:ccrc:rxortx} will break, then it waits for the timeslot to end and then resets the clock and starts the loop over. 